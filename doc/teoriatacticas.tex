\chapter{Tácticas en Lean}\label{apentacti}

En el apéndice que se presenta a continuación, se van a explicar de manera
detalla las diferentes tácticas usadas durante el desarrollo del trabajo.
Con el objetivo de clarificar las ideas, se plantearán diferentes ejemplos
para ver cómo actuán las diversas tácticas.

Muchos de los ejemplos que he usado para la clarificación de las diferentes
tácticas han sido obtenidos del tutorial que realicé para comenzar a trabajar
con Lean, en concreto \cite{tutor}.

\section{Táctica sorry}

La primera táctica que vamos a estudiar es la táctica \tactica{sorry}{sorry}.
En particular, esta táctica es muy útil y tiene una función muy sencilla:
es capaz de probar cualquier resultado. Ahora bien, a nosotros no nos interesa
usar esta táctica para la formalización como tal de las pruebas pero sí como
herramienta de ayuda que nos permita formalizar resultados auxiliares o
hechos dentro de una prueba.

Realmente cualquier ejemplo, lema o teorema sería válido para ver cómo funciona
esta táctica. Veámos el siguiente:
\begin{leancode}
example (h₁ : a ∣ b) (h₂ : b ∣ c) : a ∣ c :=
begin
  sorry,
end
\end{leancode}

Asimismo, veámos un ejemplo en el que la táctica \tactica{sorry}{sorry} sea
utilizada con la función de probar un hecho dentro de la prueba. Es más,
en este ejemplo aparecen las dos funciones mencionadas de la táctica:
\begin{leancode}
example (a b : ℝ) : a = a*b → a = 0 ∨ b = 1 :=
begin
  intro hyp,
  have H : a*(1 - b) = 0, by sorry,
  sorry,
end
\end{leancode}

\section{Táctica rewrite}

A continuación, se presenta la táctica \tactica{rw / rewrite}{rw}. Esta táctica
es muy usada y su forma de funcionar es muy intuitiva: consiste en reemplazar
la ecuación o el si y solamente si que se encuentre después de la táctica
\tactica{rw / rewrite}{rw} sobre el objetivo a demotrar.

Si a continuación de la táctica \tactica{rw / rewrite}{rw} se encuentra una
flecha hacia la izquierda (\(←\)) se tiene que la sustitución es aplicada
al revés.

En el ejemplo que se presenta a continuación se pueden observar los dos usos
de la táctica \tactica{rw / rewrite}{rw} que hemos mencionado:

\begin{leancode}
example (a b : ℝ) : (a + b)*(a - b) = a^2 - b^2 :=
begin
  rw mul_sub (a+b) a b,
  rw add_mul a b b,
  rw pow_two a,
  rw pow_two b,
  rw mul_comm a b,
  rw ← sub_sub ((a+b)*a) (b*a) (b*b),
  rw add_mul a b a,
  rw ← add_sub,
  rw sub_self,
  rw add_zero (a*a), 
end
\end{leancode}

Asimismo, otra función de la táctica \tactica{rw / rewrite}{rw} de la cual se
ha hecho uso durante el desarrollo del trabajo es aplicar la sustitución en
alguna hipótesis y no en el objetivo a demostrar. Esto se hace haciendo uso
del predicado \texttt{at}; veámoslo en Lean:
\begin{leancode}
example (a b c d : ℝ) (hyp : c = d*a + b) (hyp' : b = a*d) : c = 2*a*d :=
begin
  rw hyp' at hyp,
  rw mul_comm d a at hyp,
  rw ← two_mul (a*d) at hyp,
  rw ← mul_assoc 2 a d at hyp,
  exact hyp,
end
\end{leancode}

En este ejemplo se pueden observar las tres funciones descritas de la táctica
\tactica{rw / rewrite}{rw}. 

\section{Táctica have}
La siguiente táctica a estudiar será la táctica \tactica{have}{have}. Esta
táctica es usada cuando se quieren introducir nuevas hipótesis al problema que
tendrán que ser demostradas luego.

En este caso el mismo ejemplo que uno de los que usamos para estudiar la táctica
\tactica{sorry}{sorry}. Este ejemplo era:

\begin{leancode}
example (a b : ℝ) : a = a*b → a = 0 ∨ b = 1 :=
begin
  intro hyp,
  have H : a*(1 - b) = 0, by sorry,
  sorry,
end
\end{leancode}

\section{Táctica exact}
La táctica \tactica{exact}{exact} ha sido una de las más utilizadas en el
trabajo y cuya función es muy simple: nos introduce una prueba directa del
objetivo a demostrar.

Para ver un ejemplo del uso de esta táctica, también se va a hacer uso de uno
ya propuesto anteriormente y es uno de los que se estudió al ver la táctica
\tactica{rw / rewrite}{rw}. El ejemplo era el siguiente:

\begin{leancode}
example (a b c d : ℝ) (hyp : c = d*a + b) (hyp' : b = a*d) : c = 2*a*d :=
begin
  rw hyp' at hyp,
  rw mul_comm d a at hyp,
  rw ← two_mul (a*d) at hyp,
  rw ← mul_assoc 2 a d at hyp,
  exact hyp,
end
\end{leancode}


\section{Táctica intro}
La siguiente táctica que se va a introducir es \tactica{intro / intros}{intro}

\section{Táctica apply}
La táctica \tactica{apply}{apply} es la siguiente que vamos a introducir. La
función de esta táctica trata de unificar el objetivo a demostrar con la
conclusión de un resultado auxiliar (el que se especifique justo después de
aplicar la táctica). De manera que si unifica, los objetivos a demostrar pasan
a ser las diversas premisas que tuviese el resultado usado.

Veámos un ejemplo en el que se utiliza esta táctica:
\begin{leancode}
def non_decreasing (f : ℝ → ℝ) := ∀ x₁ x₂, x₁ ≤ x₂ → f x₁ ≤ f x₂
def non_increasing (f : ℝ → ℝ) := ∀ x₁ x₂, x₁ ≤ x₂ → f x₁ ≥ f x₂

example (f g : ℝ → ℝ) (hf : non_decreasing f) (hg : non_increasing g) : 
non_increasing (g ∘ f) :=
begin
  intros x1 x2 h,
  apply hg,
  apply hf,
  exact h,
end
\end{leancode}


\section{Táctica linarith}
La siguiente táctica ha sido otra muy utilizada en el trabajo y es
\tactica{linarith}{linarith}. Esta táctica trata de encontrar una contradicción
entre las hipótesis del problema que son igualdades o desigualdades. En el
ejemplo que se plantea a continuación se puede ver de manera muy clara:

\begin{leancode}
def up_bounds (A : set ℝ) := { x : ℝ | ∀ a ∈ A, a ≤ x}
def is_max (a : ℝ) (A : set ℝ) := a ∈ A ∧ a ∈ up_bounds A
infix ` is_a_max_of `:55 := is_max

example (A : set ℝ) (x y : ℝ) (hx : x is_a_max_of A) (hy : y is_a_max_of A) :
x = y :=
begin
  have : x ≤ y, from hy.2 x hx.1,
  have : y ≤ x, from hx.2 y hy.1,
  linarith,
end
\end{leancode}

Se tienen dos hipótesis: por un lado que \(x\) es menor o igual que \(y\) y por
otro que \(y\) es menor o igual que \(x\). Entonces, con la táctica
\tactica{linarith}{linarith} se prueba directamente que \(x\) es igual a \(y\).

\section{Táctica nlinarith}
La táctica \tactica{nlinarith}{nlinarith}, que es la que vamos a estudiar a
continuaón, es muy parecida a la táctica \tactica{linarith}{linarith} que
acabamos de describir. Realmente la táctica \tactica{nlinarith}{nlinarith} no
es más que una extensión de la táctica \tactica{linarith}{linarith} que puede
resolver problemas no lineales.

Veámos un ejemplo de esta táctica en Lean:
\section{Táctica assume}

\section{Táctica by contradiction}

\section{Táctica let}

\section{Táctica use}

\section{Táctica induction}

\section{Táctica cases}

\section{Táctica from}

\section{Tácticas left y right}

\section{Táctica library search}

\section{Táctica norm num}

\section{Táctica refine}

\section{Táctica ring}

Táctica ring:
\begin{leancode}
example (a b : ℝ) : (a + b) + a = 2*a + b :=
begin
  by ring,
end
\end{leancode}

\section{Tácticas simp y simpa}

\section{Táctica split}

\section{Táctica suggest}

